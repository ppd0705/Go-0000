
## 第一课

### 1. 微服务概览

#### 微服务
- 优点
  - 围绕业务功能构建，原子服务，关注单一业务
  - 独立进程
 - 隔离部署
- 缺点
  - 微服务是一个分布式系统，更加负载，必须依赖RPC来实现通信
  - 数据库也进行了拆分，同时更新多个业务的事务变得很困难
  - 测试更加复杂
  - 基础设施挑战更大

#### 组件服务化
将单体应用拆散为一系列的服务运行在不同的进程中

#### 按业务组织服务
- 服务提供的能力和业务功能对应
- 开发团队对生产环境负全部责任

#### 去中心化
- 数据去中心化：每个服务独享自身的数据存储设施（缓存、数据库）
- 治理去中心化：如服务发现增减节点 
- 技术去中心化：尽量收敛编程语言
#### 基础设施自动化
- CICD: gitlab + gitlab hooks + k8s
- 测试：测试环境、单元测试、API自动化测试（如yapi）
- 运行时监控和报警

#### 可用性和兼容性设计
Design For Failure设计思想:任何环境都可能出故障

##### 可用性

- 隔离
- 超时控制
- 负载保护
- 限流
- 降级
- 重试
- 负载均衡

##### 兼容性：
- 发送时保守：最小化发送必要的信息
- 接收时开放：最大限度容忍冗余数据


### 2. 微服务设计

####  BFF(backend for frontend)

前轻后重，面向业务而非面向资源，后端做数据组装
按业务域拆封BFF，做数据组装
API Gateway做鉴权、限流等基础功能

#### 微服务划分
- 按部门划分：一个闭环的团队负责一个服务 
- 按业务域（DDD Bounded Context）划分
####  微服务安全
##### 外部服务
- API Gateway( user token) --> BFF (JWT) --> Service (Request Args)
##### 内部服务
先身份认证后授权认证

### 3. GRPC和服务发现
#### GRPC
- 自定义meta
- 标准的HealthCheck
#### 服务发现
##### 客户端发现
客户端使用一个负载均衡算法选择一个服务端实现
##### 服务端发现
客户端连LB， 多一次网络通信开销
##### Bilibili开源服务发现discovery
- Privider注册后定期心跳一次
- Consumer启动时拉取实例信息
- Discovery Server定期检测失效实体

### 4. 多集群和多租户

#### 多集群
一个服务建立多套集群，不同集群使用不同的缓存
  - 客户端从全集群中选取子集连接

#### 多租户

- 给节点打标签，通过http header加标签信息一路请求到指定节点
- 数据库/缓存公用，数据加标签
- 需要造假数据


