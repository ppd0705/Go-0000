第十二周：Runtime
---

## Goroutine原理
Goroutine是一个与其他goroutine并行运行在同一地址空间的Go函数和方法

### 特性
- 内存占用：初始分配2KB，运行过程中可以自动扩容，而thread会默认分配一个1-8MB的栈内存，且不可扩容
- 创建/销毁：在用户态进行
- 调度切换：切换成本远比线程小
- 复杂性：通讯简单，创建和退出简单

### GMP
G：goroutine
M: thread
P: local queue 
### M:N模型
Go runtime会创建M个线程，之后的多个N个goroutine都会依附在这M个线程上执行

### goroutine的创建
- G0
- M0

### syscall
Go封装了了syscall

## 内存分配原理
### 堆栈 和 逃逸分析
go每个goroutine都有自身的栈,初始大小为2KB

go编译器会做逃逸分析，决定变量分配在栈还是堆上

### 连续栈
栈扩容： 编译器在编译时会进行一定的判断逻辑在部分函数里面插入runtime.morestack

### 内存管理
Go内存管理借鉴了TCMalloc

核心问题： 内存碎片、 大锁

方法：每个P有一个mcache, mcache有对应的mspaan, 分配不同大小的span, 新建对象时分配合适大小的span


### 实践优化
- 小结构体合并（组合，不用指针，减少对象数量）
- slice、map预创建指定大小，以免不定append
- 字符串拼接使用strings.Builder
- 减少不必要的memory copy(操作多个buffer时可用readv/writev)
- 使用内存逃逸分析工具分析

## GC原理

主流算法
- 引用计数
- 追踪式垃圾回收， 如标记清除 mark and sweep

golang演进
- 1.3版本之前，标记清楚整个过程需要STW
- 1.3版本时分离了标记和清除的操作，标记过程STW，清除过程后台并发执行
- 1.5版本标记使用了三色标记法，标记阶段的前后需要STW来做GC的准备工作和栈的re-scan，标记和清除阶段可以并发执行


三色标对象
- 白色：潜在的垃圾
- 灰色：活跃的对象，因为存在指向白色对象的指针，扫描器会扫描这些对象的子对象
- 黑色：活跃的对象，包括不存在任何外部指正的对象根对象可达的对象，扫描器不会扫描这些对象

三色不变形
- 强三色不变形：黑色对象不会只想白色对象，只会只想灰色或者黑色对象
- 弱三色不变形：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

写屏障：将黑色对象指向的白色对象改为灰色
删除屏障：拦截写操作，通过保护灰色对象到白色对象的路径不会断
 
## channel原理